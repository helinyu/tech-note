# C++ vs OC

C++ 和 Objective-C 在实现多态时，都遵循面向对象编程的基本原则，但由于它们的语言特性和设计哲学不同，多态的实现方式也有显著的区别和一些共同点。下面对两者在实现多态上的相同点和不同点进行比较。

#### 相同点

1. **继承和方法重写**：
   * **相同点**：C++ 和 Objective-C 都使用**继承**和**方法重写**来实现多态。父类定义一个方法，子类可以重写该方法，从而在运行时根据对象的实际类型来调用相应的实现。
   * **示例：**
     * 在 C++ 中，使用 `virtual` 关键字定义父类的方法为虚函数，使得派生类可以重写并实现多态。
     * 在 Objective-C 中，默认情况下，所有方法都可以被重写，表现出类似的动态行为。
2. **基类指针/引用调用派生类方法**：
   * 在两种语言中，通过基类的指针或引用可以指向派生类的对象，并且在运行时调用派生类的重写方法。
   * **示例：**
     * 在 C++ 中，使用基类的指针调用虚函数来实现运行时多态。
     * 在 Objective-C 中，通过基类指针或 `id` 类型的动态分派来实现相同的效果。
3. **运行时决定方法实现**：
   * **相同点**：两种语言的运行时都会根据实际对象的类型决定调用哪个方法。这种特性是面向对象语言中多态的核心思想。

#### 不同点

**1. 编译时与运行时的差异**

* **C++**：
  * C++ 是静态类型语言，多态的实现依赖于**虚函数表（vtable）**。编译时，编译器会为类生成一个虚函数表，虚函数表包含指向实际函数的指针。在运行时，当调用虚函数时，系统会根据对象的类型在虚函数表中查找并调用相应的方法。
  * 虚函数的定义需要显式地使用 `virtual` 关键字，没有声明为虚函数的方法无法被重写。
* **Objective-C**：
  * Objective-C 是动态类型语言，依赖于**消息传递机制**。每个对象接收到消息时，运行时系统会根据消息的选择器（selector）动态查找方法实现。如果找不到对应的方法，系统会触发动态方法解析机制。这意味着在运行时才真正确定调用哪个方法。
  * 所有方法都隐含地可以被重写，无需像 C++ 那样显式声明。

**2. 多态的类型检查**

* **C++**：
  * 由于 C++ 是静态类型语言，多态依赖于编译时的类型检查和运行时的虚函数表。在编译时，编译器会进行类型检查，如果类型不匹配，会在编译时提示错误。
  * 静态类型的强约束意味着编译时的错误更容易发现，但代码灵活性相对较低。
* **Objective-C**：
  * Objective-C 是动态类型语言，更多的类型检查发生在运行时。编译器不会在编译时严格检查对象类型，而是通过 `id` 类型允许动态绑定，这使得代码在运行时才决定调用哪个方法。
  * 虽然这种机制提高了灵活性，但可能导致一些错误直到运行时才会暴露。

**3. 虚函数表 vs. 消息传递机制**

* **C++**：
  * C++ 使用虚函数表（vtable）实现多态。每个类都会有一张虚函数表，表中存储指向类中虚函数的指针。调用虚函数时，通过这张表找到实际的函数指针并进行调用。
  * 虚函数表是静态的，在编译期生成，并且在运行时通过指针查找。
* **Objective-C**：
  * Objective-C 使用动态的消息传递机制。当调用某个方法时，实际上是向对象发送了一条消息，运行时系统会根据对象的类型和方法的选择器（selector）找到相应的方法并执行。
  * 这种机制使得 Objective-C 的多态表现更加动态和灵活，允许在运行时修改类行为（例如：方法交换）。

**4. 方法的可重写性**

* **C++**：
  * 在 C++ 中，只有通过 `virtual` 关键字定义的虚函数才能实现多态。派生类必须重写虚函数，并且可以使用 `override` 关键字来明确声明重写。非虚函数不能被派生类重写。
* **Objective-C**：
  * Objective-C 中，任何方法都可以被子类重写，不需要像 C++ 那样显式声明虚函数。默认情况下，所有的实例方法在子类中都是可重写的。

**5. 动态绑定与性能**

* **C++**：
  * C++ 是静态类型的，编译时确定类型信息。使用虚函数表查找函数指针的机制在性能上比动态消息传递要快一些，因为它依赖于编译时的优化。
* **Objective-C**：
  * Objective-C 的动态绑定和消息传递机制灵活，但由于运行时查找方法的开销较大，在某些情况下性能可能不如 C++ 的虚函数调用。尽管如此，Objective-C 依然有优化机制来降低这一性能影响。

#### 总结

| 比较点       | C++                           | Objective-C           |
| --------- | ----------------------------- | --------------------- |
| **语言类型**  | 静态类型语言                        | 动态类型语言                |
| **多态的实现** | 通过虚函数表（vtable）                | 通过消息传递机制              |
| **虚函数**   | 必须使用 `virtual` 关键字声明，派生类可以重写  | 所有方法默认可以被重写           |
| **类型检查**  | 编译时检查，依赖于静态类型                 | 运行时检查，使用 `id` 动态类型    |
| **函数绑定**  | 静态绑定和动态绑定，取决于是否为虚函数           | 动态绑定，通过消息传递确定方法实现     |
| **灵活性**   | 类型安全性强，编译期可检查大部分错误            | 灵活性强，允许运行时修改行为（如方法交换） |
| **性能**    | 通常比 Objective-C 快，尤其是在虚函数调用方面 | 消息传递系统灵活，但性能上有一定开销    |

总体来说，C++ 强调静态类型检查和编译时优化，而 Objective-C 则注重动态性和灵活性。两者在多态的实现上各有优势，C++ 的多态在性能和安全性上更优，而 Objective-C 的动态机制带来了更大的灵活性。
