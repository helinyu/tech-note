# 两者的单向数据流

提到两者都采用“单向数据流”的思想，的确有一些复杂的理解在里面。我们可以从 **数据流动的方向** 以及 **数据状态的触发方式** 来详细解析它们的实现逻辑：

#### 1. **MVVM 的数据流动**

在 MVVM 中，虽然整体上存在双向数据绑定，但数据的流动依然是“单向触发”的，这里的“单向触发”体现在以下几个方面：

* **数据变更的方向性**：数据总是从 `Model` 流向 `View`（通过 `ViewModel`），再从 `ViewModel` 到 `View`，这样确保 `Model` 是数据的源头，`View` 仅展示数据。视图对状态的更改是通过 `ViewModel` 间接触发模型的改变，而不是直接修改 `Model`，这就保证了在状态的源头是一致的。
* **事件触发的数据流**：用户的操作并不会直接更新 `Model`，而是通过 `ViewModel` 中的事件处理，将用户的输入解析为对 `Model` 的更新需求，这就是单向触发的数据流，避免了 `View` 和 `Model` 的直接耦合。

因此，虽然 MVVM 中有双向绑定的实现，但数据始终由 `Model` 统一流向 `View`。`View` 更新并不会直接反向修改数据源，而是通过 `ViewModel` 触发新的数据流，这种间接的双向绑定可以被看作单向流动的思想。

#### 2. **MVI 的数据流动**

MVI 模式则明确地实现了严格的单向数据流，它的单向数据流动思想可以分为以下几个环节：

* **数据的不可变状态**：每当 `Model` 层根据用户的 `Intent` 更新数据时，都会生成一个新的 `State`（不可变状态）。这个 `State` 是单一数据源，并不会被 `View` 层修改。
* **单一状态驱动视图**：在 MVI 中，`State` 是视图展示的唯一依据。每次 `State` 的更新都会触发 `View` 的重新渲染，而 `View` 本身没有能力去反向修改状态。用户的操作仅会生成新的 `Intent`，通过 `Intent` 处理再更新 `Model` 的状态。

这种单一的状态源使 MVI 模式下的数据流动完全保持在一个方向上，避免了状态冲突和循环依赖。因为 `State` 是不可变的，**视图的更新是根据单一的状态快照进行渲染**，从而在复杂的状态管理下保持稳定和一致性。

#### 总结

在 MVVM 和 MVI 中，**数据的单向流动** 都是通过让视图层不能直接操作数据源来实现的。即使 MVVM 有双向绑定的特性，数据的变化依然通过 `ViewModel` 或 `Model` 来集中管理，从而确保应用的整体数据流是有方向性的，而非杂乱无序的双向更改。
