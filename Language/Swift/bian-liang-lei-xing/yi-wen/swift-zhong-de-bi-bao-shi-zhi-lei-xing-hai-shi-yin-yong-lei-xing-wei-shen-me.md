# swift中的闭包是值类型还是引用类型？为什么？

在 Swift 中，闭包是值类型。

**原因如下：**

1. **值语义特性**：
   * 当闭包被赋值给一个变量或者作为参数传递给一个函数时，会进行值的复制，就像结构体等值类型一样。这意味着每个副本都是独立的，对一个副本的修改不会影响到其他副本。
   *   例如：

       ```swift
       let closure1 = { () -> Void in
           print("Closure 1")
       }
       let closure2 = closure1
       closure1() // 输出 "Closure 1"
       closure2() // 输出 "Closure 1"
       ```
   * 在这里，将 `closure1` 赋值给 `closure2` 时发生了值的复制，修改其中一个闭包不会影响到另一个。
2. **符合 Swift 的设计理念**：
   * Swift 强调安全性和可预测性。将闭包设计为值类型有助于避免意外的共享和副作用。这样可以让开发者更清楚地理解代码的行为，减少潜在的错误。
   * 与值类型的结构体和枚举类似，闭包的这种值类型特性使得代码更加可靠和易于维护。
3. **捕获值的方式**：
   * 当闭包捕获外部变量时，实际上是将这些变量的值复制到闭包的内部环境中。这进一步体现了闭包的值语义。
   *   例如：

       ```swift
       var count = 0
       let incrementClosure = {
           count += 1
           print(count)
       }
       incrementClosure()
       incrementClosure()
       ```
   * 在这个例子中，闭包捕获了外部变量 `count`，但对 `count` 的修改是在闭包的副本中进行的，不会影响到其他可能存在的闭包副本。
