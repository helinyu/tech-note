# std::set 应用场景

`std::set`是 C++ 标准模板库中的关联容器，它存储一组唯一的元素，并按照特定的严格弱序进行排序。以下是一些常见的应用场景：

**一、数据去重**

1. 处理输入数据：
   * 当从外部源（如文件、用户输入或网络流）接收数据时，可能会存在重复的值。使用`std::set`可以轻松地去除这些重复值，确保处理的数据是唯一的。
   * 例如，从一个文本文件中读取单词，并去除重复的单词。可以逐行读取文件，将每个单词插入到`std::set<std::string>`中，`set`会自动去除重复的单词。
2. 算法中间结果去重：
   * 在某些算法中，可能会产生中间结果，这些结果可能包含重复的值。使用`std::set`可以在算法的不同阶段对中间结果进行去重，以减少后续处理的工作量。
   * 比如，在图的遍历算法中，可能会记录访问过的节点。使用`std::set`可以确保不会重复访问同一个节点，提高算法的效率和正确性。

**二、集合操作**

1. 交集、并集和差集：
   * `std::set`支持集合的基本操作，如交集、并集和差集。可以使用这些操作来处理多个集合之间的关系，例如在数据库查询、数据过滤和分析等场景中。
   *   例如，有两个集合 A 和 B，需要找到它们的交集。可以使用以下代码：

       ```cpp
       std::set<int> setA = {1, 2, 3, 4, 5};
       std::set<int> setB = {3, 4, 5, 6, 7};
       std::set<int> intersection;
       std::set_intersection(setA.begin(), setA.end(), setB.begin(), setB.end(), std::inserter(intersection, intersection.begin()));
       // intersection 中包含 3、4、5。
       ```
2. 成员关系判断：
   * 可以快速判断一个元素是否属于一个集合。由于`std::set`的查找操作具有对数时间复杂度，因此在处理大量元素时，比线性搜索更高效。
   *   例如，判断一个数字是否在一个给定的集合中：

       ```cpp
       std::set<int> mySet = {1, 2, 3, 4, 5};
       bool isMember = (mySet.find(3)!= mySet.end());
       // isMember 为 true，表示 3 是集合中的元素。
       ```

**三、维护有序的唯一列表**

1. 动态更新的有序列表：
   * 在一些应用中，需要维护一个动态更新的有序列表，同时确保列表中的元素是唯一的。`std::set`可以满足这个需求，因为它自动对元素进行排序，并防止重复元素的插入。
   * 比如，在一个实时数据处理系统中，需要不断接收新的数据，并将其插入到一个有序的列表中。使用`std::set`可以确保列表始终保持有序且不包含重复数据。
2. 快速访问特定范围内的元素：
   * 由于`std::set`是有序的，可以使用迭代器快速访问特定范围内的元素。这在需要对数据进行范围查询或筛选的场景中非常有用。
   *   例如，查找一个集合中大于等于某个值的所有元素：

       ```cpp
       std::set<int> mySet = {1, 2, 3, 4, 5};
       int lowerBound = 3;
       auto it = mySet.lower_bound(lowerBound);
       for (; it!= mySet.end(); ++it) {
           std::cout << *it << " ";
       }
       // 输出 3、4、5。
       ```

**四、作为算法的辅助数据结构**

1. 图算法：
   * 在图的算法中，`std::set`可以用于存储已访问的节点、待处理的节点或其他相关信息。例如，在深度优先搜索或广度优先搜索中，可以使用`std::set`来记录已访问的节点，避免重复访问。
   *   假设在一个图的遍历算法中，使用`std::set`来存储已访问的节点：

       ```cpp
       std::set<int> visitedNodes;
       void dfs(int node, std::vector<std::vector<int>>& graph) {
           visitedNodes.insert(node);
           for (
       ```
