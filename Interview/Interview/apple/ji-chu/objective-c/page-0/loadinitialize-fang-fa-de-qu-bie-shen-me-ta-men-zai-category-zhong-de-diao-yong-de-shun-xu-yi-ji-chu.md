# load、initialize方法的区别什么？它们在category中的调用的顺序？以及出现继承时他们之间的调用过程？

在 Objective-C 中，`+load` 和 `+initialize` 是两个类方法，它们的区别和调用顺序各自有不同的规则。以下是详细解释：

#### 1. `+load` 方法：

* **调用时机**：`+load` 方法在类或分类（category）被加载到内存时自动调用，通常是在程序启动时。它的调用顺序非常严格，**在 main 函数执行之前就会调用**。
* **调用顺序**：
  * **先调用类的 `+load` 方法**，再调用该类所关联的所有分类的 `+load` 方法。
  * 对于同一个类及其分类，`+load` 的调用顺序是按 **编译顺序** 来决定的，编译在前的类或分类会先调用。
  * 如果类有继承结构，**先调用父类的 `+load` 方法，再调用子类的 `+load` 方法**。
* **特点**：
  * 每个类和分类的 `+load` 方法都会被调用，**即使没有显式调用父类的 `+load` 方法，父类也会自动调用自己的 `+load`**。
  * `+load` 方法是线程安全的，且是在非常早的阶段调用的，通常用于对类或系统做一些全局初始化的操作。

#### 2. `+initialize` 方法：

* **调用时机**：`+initialize` 方法是在类或分类 **第一次被使用时** 调用。通常是在类或实例方法首次被调用时，系统会自动调用 `+initialize` 方法。
* **调用顺序**：
  * 在类使用之前，先调用其父类的 `+initialize`，再调用子类的 `+initialize`。
  * **分类的 `+initialize`** 只会在分类中的方法被调用时执行，且如果类的 `+initialize` 已经调用过，那么分类的 `+initialize` 可能不会再被调用。
  * 如果类有多个分类，并且都实现了 `+initialize`，那么 **只会调用一次**，通常是类本身的 `+initialize`，而不是所有分类的。
* **特点**：
  * `+initialize` 方法不是必须的，**如果子类没有定义 `+initialize`，则继承父类的实现**。
  * 由于 `+initialize` 是在类第一次使用时调用的，所以它的调用顺序相对较晚，且**不会重复调用**。

#### 3. 在 Category 中的调用顺序：

对于 `+load` 和 `+initialize`，在有分类的情况下，调用顺序也有差异：

* **`+load` 方法**：
  * 主类和所有分类的 `+load` 都会被调用。
  * 如果存在多个分类，按照编译顺序（即在编译时的物理文件顺序）调用。
* **`+initialize` 方法**：
  * 对于 `+initialize`，只会调用一次，通常是主类的 `+initialize`，分类中的 `+initialize` 不会覆盖主类的实现，除非分类中的方法被直接调用。

#### 4. <mark style="color:red;">继承情况下的调用顺序</mark>：

* **`+load` 调用顺序**：
  1. 先调用父类的 `+load` 方法。
  2. 再调用子类的 `+load` 方法。
  3. 接着是父类的分类 `+load` 方法。
  4. 最后调用子类的分类 `+load` 方法。
* **`+initialize` 调用顺序**：
  1. 先调用父类的 `+initialize`。
  2. 然后调用子类的 `+initialize`。
  3. 如果分类中定义了 `+initialize`，则仅当分类中的方法被首次使用时调用。

#### 总结：

* `+load` 方法在类加载时调用，顺序严格，主类和分类的每个 `+load` 都会被执行。 父类->子类  类 ->分类
* `+initialize` 方法在类或分类第一次使用时调用，且父类优先，子类次之，并且通常只调用一次。
